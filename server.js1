require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const WebSocket = require('ws');
const http = require('http');
const path = require('path');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

// Storage
const conversations = new Map();
const humanAgents = new Map();
const waitingQueue = [];

// Knowledge Base
const knowledgeBase = [
  {
    topic: "product_features",
    content: "Our platform offers real-time analytics, automated reporting, and customizable dashboards."
  },
  // ... (rest of your knowledge base)
];

// ========== UTILITY FUNCTIONS ========== //
function searchKnowledgeBase(query) {
  const queryLower = query.toLowerCase();
  return knowledgeBase.filter(item => {
    const contentLower = item.content.toLowerCase();
    const topicLower = item.topic.toLowerCase();
    return contentLower.includes(queryLower.split(' ')[0]) || 
           topicLower.includes(queryLower.split(' ')[0]) ||
           queryLower.includes(topicLower.replace('_', ' '));
  });
}

async function generateAIResponse(userMessage, conversationHistory) {
  const relevantKnowledge = searchKnowledgeBase(userMessage);
  
  let context = "You are a helpful customer service AI assistant. ";
  
  if (relevantKnowledge.length > 0) {
    context += "Here's relevant information from our knowledge base:\n";
    relevantKnowledge.forEach(item => {
      context += `- ${item.content}\n`;
    });
  }

  context += `
Rules:
1. Answer based on the knowledge base when possible
2. If you cannot answer from the knowledge base, politely say so and offer to connect them with a human agent
3. Be helpful, friendly, and concise
4. If the user asks to speak with a human, respond with "HUMAN_REQUEST" exactly

User question: ${userMessage}`;

  const result = await model.generateContent(context);
  const response = result.response.text();
  
  if (response.includes("HUMAN_REQUEST") || 
      response.toLowerCase().includes("connect with a human") ||
      response.toLowerCase().includes("speak with a human")) {
    return "I'd be happy to connect you with one of our human agents who can better assist you. Please wait a moment while I find someone available.";
  }
  
  return response;
}

// ========== WEBSOCKET HANDLERS ========== //
async function handleCustomerMessage(ws, sessionId, message) {
  if (!conversations.has(sessionId)) {
    conversations.set(sessionId, {
      customerWs: ws,
      messages: [],
      hasHuman: false,
      agentWs: null
    });
  }

  const conversation = conversations.get(sessionId);
  conversation.messages.push({ role: 'user', content: message });

  if (conversation.hasHuman && conversation.agentWs) {
    conversation.agentWs.send(JSON.stringify({
      type: 'customer_message',
      sessionId,
      message
    }));
    return;
  }

  try {
    const aiResponse = await generateAIResponse(message, conversation.messages);
    conversation.messages.push({ role: 'assistant', content: aiResponse });
    
    ws.send(JSON.stringify({
      type: 'ai_response',
      message: aiResponse,
      sessionId
    }));
  } catch (error) {
    console.error('AI Response error:', error);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Sorry, I encountered an error. Would you like to connect with a human agent?'
    }));
  }
}

function handleAgentJoin(ws, agentId) {
  humanAgents.set(agentId, ws);
  ws.send(JSON.stringify({
    type: 'agent_status',
    message: `You're now available as agent ${agentId}`,
    waitingCustomers: waitingQueue.length
  }));

  waitingQueue.forEach(sessionId => {
    ws.send(JSON.stringify({
      type: 'pending_request',
      sessionId,
      position: waitingQueue.indexOf(sessionId) + 1
    }));
  });
}

function handleAcceptRequest(sessionId, agentId) {
  const conversation = conversations.get(sessionId);
  if (!conversation) return;

  const agentWs = humanAgents.get(agentId);
  if (!agentWs) return;

  conversation.hasHuman = true;
  conversation.agentWs = agentWs;

  conversation.customerWs.send(JSON.stringify({
    type: 'human_joined',
    message: 'A human agent has joined the chat!'
  }));

  agentWs.send(JSON.stringify({
    type: 'customer_assigned',
    sessionId,
    conversationHistory: conversation.messages
  }));

  const index = waitingQueue.indexOf(sessionId);
  if (index > -1) {
    waitingQueue.splice(index, 1);
  }
}

function handleAgentMessage(sessionId, message) {
  const conversation = conversations.get(sessionId);
  if (conversation && conversation.customerWs) {
    conversation.messages.push({ role: 'agent', content: message });
    conversation.customerWs.send(JSON.stringify({
      type: 'agent_message',
      message
    }));
  }
}

function handleEndChat(sessionId) {
  const conversation = conversations.get(sessionId);
  if (conversation) {
    conversation.customerWs.send(JSON.stringify({
      type: 'agent_left',
      message: 'The agent has ended the chat. You can continue with the AI assistant.'
    }));
    conversation.hasHuman = false;
    conversation.agentWs = null;
  }
}

async function handleHumanRequest(sessionId) {
  const conversation = conversations.get(sessionId);
  if (!conversation) return;

  if (!waitingQueue.includes(sessionId)) {
    waitingQueue.push(sessionId);
  }

  humanAgents.forEach(agentWs => {
    agentWs.send(JSON.stringify({
      type: 'pending_request',
      sessionId,
      position: waitingQueue.indexOf(sessionId) + 1
    }));
  });

  conversation.customerWs.send(JSON.stringify({
    type: 'waiting_for_human',
    message: 'You have been added to the queue. A human agent will be with you shortly.'
  }));
}

async function handleWebSocketMessage(ws, data) {
  const { type, sessionId, message, agentId } = data;

  switch (type) {
    case 'customer_message':
      await handleCustomerMessage(ws, sessionId, message);
      break;
    case 'agent_join':
      handleAgentJoin(ws, agentId);
      break;
    case 'agent_message':
      handleAgentMessage(sessionId, message);
      break;
    case 'request_human':
      await handleHumanRequest(sessionId);
      break;
    case 'accept_request':
      handleAcceptRequest(sessionId, agentId);
      break;
    case 'end_chat':
      handleEndChat(sessionId);
      break;
  }
}

// ========== WEBSOCKET SETUP ========== //
wss.on('connection', (ws) => {
  console.log('New WebSocket connection');

  ws.on('message', async (message) => {
    try {
      const data = JSON.parse(message);
      
      if (data.type === 'agent_join') {
        if (data.secretKey !== process.env.AGENT_SECRET) {
          ws.send(JSON.stringify({ 
            type: 'error', 
            message: 'Invalid agent credentials' 
          }));
          ws.close();
          return;
        }
      }
      
      await handleWebSocketMessage(ws, data);
    } catch (error) {
      console.error('WebSocket error:', error);
    }
  });

  ws.on('close', () => {
    for (const [agentId, agentWs] of humanAgents) {
      if (agentWs === ws) {
        humanAgents.delete(agentId);
        break;
      }
    }
    for (const [sessionId, session] of conversations) {
      if (session.customerWs === ws || session.agentWs === ws) {
        conversations.delete(sessionId);
        break;
      }
    }
  });
});

// ========== ROUTES ========== //
app.get('/agent', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/agent.html'));
});

app.get('/health', (req, res) => {
  res.json({ status: 'OK' });
});

server.listen(process.env.PORT || 3000, () => {
  console.log(`Server running on port ${process.env.PORT || 3000}`);
});
